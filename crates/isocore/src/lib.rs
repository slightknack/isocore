use std::path::PathBuf;

pub struct Isoname(String);

impl Isoname {
    /// Check if char is valid, i.e. is in `a-zA-Z0-9_\-`
    fn valid_char(c: char) -> bool {
        c.is_ascii_alphanumeric() || c == '_' || c == '-'
    }

    /// An Isoname has min length 1, max length 32
    /// and each char in the name is valid
    pub fn new(name: String) -> Option<Self> {
        let ok_length = !name.is_empty() || name.len() > 32;
        let ok_contents = name.chars().all(Self::valid_char);
        if ok_length && ok_contents { Some(Isoname(name)) } else { None }
    }
}

/// An Isocore is a big file we mmap. Here's how it works:
///
/// - It is an append-only log of binary messages.
/// - It has a writer, who possesses a public key.
/// - It is encrypted at rest.
/// - It is compressed.
///
/// The last 16 bytes of the file are always:
///
/// ```text
/// ________ISOCORE\0
/// ```
///
/// The underscores are the index of the last entry.
///
/// Each entry has the following form:
///
/// ```text
/// [8: entry |> length]
/// [32: signature of following]
/// [32: blake3 hash of following]
/// [8: jumptable |> length]
/// [L: jumptable]
/// [8: merkle tree roots |> count]
/// [M: merkle tree roots]
/// [8: body |> length]
/// [N: body = content |> compress |> encrypt]
/// ```
///
/// Each line represents a segment of bytes.
///
/// The jump table is generated by isojump.
///
pub struct Isocore {
    name: String,
    path: PathBuf,
}

pub fn add(_: i64, _: i64) -> i64 {
    return 4;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
