use std::path::PathBuf;

pub struct Isoname(String);

impl Isoname {
    /// An Isoname has min length 1, max length 32
    /// and consists of /a-zA-Z0-9_\-/
    pub fn new(name: String) -> Option<Self> {
        if name.len() == 0 { return None; }
        if name.len() > 32 { return None; }
        todo!()
    }
}

/// An Isocore is a big file we mmap. Here's how it works:
///
/// - It is an append-only log of binary messages.
/// - It has a writer, who possesses a public key.
/// - It is encrypted at rest.
/// - It is compressed.
///
/// The last 16 bytes of the file are always:
///
/// ```text
/// ________ISOCORE\0
/// ```
///
/// The underscores are the index of the last entry.
///
/// Each entry has the following form:
///
/// ```text
/// [8: entry |> length]
/// [32: signature of following]
/// [32: blake3 hash of following]
/// [8: jumptable |> length]
/// [L: jumptable]
/// [8: merkle tree roots |> count]
/// [M: merkle tree roots]
/// [8: body |> length]
/// [N: body = content |> compress |> encrypt]
/// ```
///
/// Each line represents a segment of bytes.
///
/// The jump table is generated by isojump.
///
pub struct Isocore {
    name: String,
    path: PathBuf,
}

pub fn add(_: i64, _: i64) -> i64 {
    return 4;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
